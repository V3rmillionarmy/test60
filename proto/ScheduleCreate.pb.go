// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0-devel
// 	protoc        v4.0.0
// source: proto/ScheduleCreate.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

//
//Create a new Scheduled Transaction. After the Scheduled Transaction is created, the Schedule ID for it is set in the receipt.
//Users are able to create the Scheduled Transactions without the need for them to sign the scheduled underlying transaction (f.e Account A creates Scheduled Transaction for Account B, C and D to sign)
//Creating immutable scheduled transaction: Scheduled Transaction can be created as immutable if the adminKey is omitted. In this case no one is able to execute ScheduleDelete operation and the Scheduled Transaction will either execute or expire
//Defining the Payer of the Transactions: By default, the payer of the Scheduled Transaction is the Account that creates it in the first place. However, users have the option to create Scheduled Transactions with Payer set to any account. If a Payer is provided, its signature will be required in order for the scheduled transaction to reach execution.
//Providing Signatures as part of the creation: Users are able to provide signatures for the Scheduled Transaction as part of the creation itself
//Idempotent Creation: Creating Scheduled Transactions is an idempotent operation in the sense that if multiple parties perform ScheduleCreate operation specifying identical transactions, only the first one will create the transaction and the other operations will append the provided signatures.
//The criteria for identical transactions is the following: If there is a previously created Scheduled Transaction, that hasn't yet been executed and all of the properties are exactly the same except for the sigMap (transactionBody, adminKey, payerAccountID and memo).
//In that sense, ScheduleCreate transaction referring to an already created Scheduled Transaction and providing the rest of the required signature(s) will cause the underlying encoded transaction to be executed!
//Note: Even though only the first ScheduleCreate Transaction will create new Scheduled Entity and the rest of them will have their signatures from the sigMap witnessed, the ScheduleID property in the TransactionReceipt will be set on all of them.
//INVALID_ACCOUNT_ID is returned if the specified payerAccountID does not exist.
//UNRESOLVABLE_REQUIRED_SIGNERS is returned if the transactionBody defines required Signatories that cannot be resolved (f.e signature from non-existing account is requested)
//UNPARSEABLE_SCHEDULED_TRANSACTION is returned if the transactionBody cannot be parsed into normal Transaction
//UNSCHEDULABLE_TRANSACTION is returned if the transactionBody is representing a transaction that is not allowed to be scheduled (f.e scheduling a ScheduleCreate transaction)
//SOME_SIGNATURES_WERE_INVALID is returned if one of the signatures provided does not represent a valid signature for any required signer
type ScheduleCreateTransactionBody struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TransactionBody []byte        `protobuf:"bytes,1,opt,name=transactionBody,proto3" json:"transactionBody,omitempty"` // The transaction serialized into bytes that must be signed
	AdminKey        *Key          `protobuf:"bytes,2,opt,name=adminKey,proto3" json:"adminKey,omitempty"`               // (optional) The Key which is able to delete the Scheduled Transaction (if tx is not already executed)
	PayerAccountID  *AccountID    `protobuf:"bytes,3,opt,name=payerAccountID,proto3" json:"payerAccountID,omitempty"`   // (optional) The account which is going to pay for the execution of the Scheduled TX. If not populated, the scheduling account is charged
	SigMap          *SignatureMap `protobuf:"bytes,4,opt,name=sigMap,proto3" json:"sigMap,omitempty"`                   // (optional) Signatures that could be provided (similarly to how signatures are provided in ScheduleSign operation) on Scheduled Transaction creation
	Memo            string        `protobuf:"bytes,5,opt,name=memo,proto3" json:"memo,omitempty"`                       // (optional) Publicly visible information about the Scheduled entity, up to 100 bytes. No guarantee of uniqueness.
}

func (x *ScheduleCreateTransactionBody) Reset() {
	*x = ScheduleCreateTransactionBody{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_ScheduleCreate_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ScheduleCreateTransactionBody) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleCreateTransactionBody) ProtoMessage() {}

func (x *ScheduleCreateTransactionBody) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ScheduleCreate_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleCreateTransactionBody.ProtoReflect.Descriptor instead.
func (*ScheduleCreateTransactionBody) Descriptor() ([]byte, []int) {
	return file_proto_ScheduleCreate_proto_rawDescGZIP(), []int{0}
}

func (x *ScheduleCreateTransactionBody) GetTransactionBody() []byte {
	if x != nil {
		return x.TransactionBody
	}
	return nil
}

func (x *ScheduleCreateTransactionBody) GetAdminKey() *Key {
	if x != nil {
		return x.AdminKey
	}
	return nil
}

func (x *ScheduleCreateTransactionBody) GetPayerAccountID() *AccountID {
	if x != nil {
		return x.PayerAccountID
	}
	return nil
}

func (x *ScheduleCreateTransactionBody) GetSigMap() *SignatureMap {
	if x != nil {
		return x.SigMap
	}
	return nil
}

func (x *ScheduleCreateTransactionBody) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

var File_proto_ScheduleCreate_proto protoreflect.FileDescriptor

var file_proto_ScheduleCreate_proto_rawDesc = []byte{
	0x0a, 0x1a, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x42, 0x61, 0x73, 0x69, 0x63,
	0x54, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x15, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2f, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0xec, 0x01, 0x0a, 0x1d, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x42, 0x6f, 0x64, 0x79, 0x12, 0x28, 0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x42, 0x6f, 0x64, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0f, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x6f, 0x64, 0x79, 0x12, 0x26,
	0x0a, 0x08, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x08, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x12, 0x38, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x65, 0x72, 0x41,
	0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44,
	0x52, 0x0e, 0x70, 0x61, 0x79, 0x65, 0x72, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44,
	0x12, 0x2b, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x4d, 0x61, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
	0x72, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x06, 0x73, 0x69, 0x67, 0x4d, 0x61, 0x70, 0x12, 0x12, 0x0a,
	0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6d, 0x65, 0x6d,
	0x6f, 0x42, 0x4b, 0x0a, 0x1a, 0x63, 0x6f, 0x6d, 0x2e, 0x68, 0x65, 0x64, 0x65, 0x72, 0x61, 0x2e,
	0x68, 0x61, 0x73, 0x68, 0x67, 0x72, 0x61, 0x70, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x50,
	0x01, 0x5a, 0x2b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x61,
	0x73, 0x68, 0x67, 0x72, 0x61, 0x70, 0x68, 0x2f, 0x68, 0x65, 0x64, 0x65, 0x72, 0x61, 0x2d, 0x73,
	0x64, 0x6b, 0x2d, 0x67, 0x6f, 0x2f, 0x76, 0x32, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_ScheduleCreate_proto_rawDescOnce sync.Once
	file_proto_ScheduleCreate_proto_rawDescData = file_proto_ScheduleCreate_proto_rawDesc
)

func file_proto_ScheduleCreate_proto_rawDescGZIP() []byte {
	file_proto_ScheduleCreate_proto_rawDescOnce.Do(func() {
		file_proto_ScheduleCreate_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_ScheduleCreate_proto_rawDescData)
	})
	return file_proto_ScheduleCreate_proto_rawDescData
}

var file_proto_ScheduleCreate_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proto_ScheduleCreate_proto_goTypes = []interface{}{
	(*ScheduleCreateTransactionBody)(nil), // 0: proto.ScheduleCreateTransactionBody
	(*Key)(nil),                           // 1: proto.Key
	(*AccountID)(nil),                     // 2: proto.AccountID
	(*SignatureMap)(nil),                  // 3: proto.SignatureMap
}
var file_proto_ScheduleCreate_proto_depIdxs = []int32{
	1, // 0: proto.ScheduleCreateTransactionBody.adminKey:type_name -> proto.Key
	2, // 1: proto.ScheduleCreateTransactionBody.payerAccountID:type_name -> proto.AccountID
	3, // 2: proto.ScheduleCreateTransactionBody.sigMap:type_name -> proto.SignatureMap
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_proto_ScheduleCreate_proto_init() }
func file_proto_ScheduleCreate_proto_init() {
	if File_proto_ScheduleCreate_proto != nil {
		return
	}
	file_proto_BasicTypes_proto_init()
	file_proto_Timestamp_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_proto_ScheduleCreate_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ScheduleCreateTransactionBody); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_ScheduleCreate_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_ScheduleCreate_proto_goTypes,
		DependencyIndexes: file_proto_ScheduleCreate_proto_depIdxs,
		MessageInfos:      file_proto_ScheduleCreate_proto_msgTypes,
	}.Build()
	File_proto_ScheduleCreate_proto = out.File
	file_proto_ScheduleCreate_proto_rawDesc = nil
	file_proto_ScheduleCreate_proto_goTypes = nil
	file_proto_ScheduleCreate_proto_depIdxs = nil
}
