// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.12.4
// source: proto/TokenUpdate.proto

package hedera_sdk_go

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// Updates an already created Token.
//If no value is given for a field, that field is left unchanged. For an immutable tokens (that is, a token created without an adminKey), only the expiry may be updated. Setting any other field in that case will cause the transaction status to resolve to TOKEN_IS_IMMUTABlE.
type TokenUpdateTransactionBody struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Token            *TokenID   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`                        // The Token to be updated
	Symbol           string     `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`                      // The new Symbol of the Token. Must be UTF-8 capitalized alphabetical string identifying the token.
	Name             string     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`                          // The new Name of the Token. Must be a string of ASCII characters.
	Treasury         *AccountID `protobuf:"bytes,4,opt,name=treasury,proto3" json:"treasury,omitempty"`                  // The new Treasury account of the Token. If the provided treasury account is not existing or deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token balance held in the previous Treasury Account is transferred to the new one.
	AdminKey         *Key       `protobuf:"bytes,5,opt,name=adminKey,proto3" json:"adminKey,omitempty"`                  // The new Admin key of the Token. If Token is immutable, transaction will resolve to TOKEN_IS_IMMUTABlE.
	KycKey           *Key       `protobuf:"bytes,6,opt,name=kycKey,proto3" json:"kycKey,omitempty"`                      // The new KYC key of the Token. If Token does not have currently a KYC key, transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
	FreezeKey        *Key       `protobuf:"bytes,7,opt,name=freezeKey,proto3" json:"freezeKey,omitempty"`                // The new Freeze key of the Token. If the Token does not have currently a Freeze key, transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
	WipeKey          *Key       `protobuf:"bytes,8,opt,name=wipeKey,proto3" json:"wipeKey,omitempty"`                    // The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction will resolve to TOKEN_HAS_NO_WIPE_KEY.
	SupplyKey        *Key       `protobuf:"bytes,9,opt,name=supplyKey,proto3" json:"supplyKey,omitempty"`                // The new Supply key of the Token. If the Token does not have currently a Supply key, transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
	AutoRenewAccount *AccountID `protobuf:"bytes,10,opt,name=autoRenewAccount,proto3" json:"autoRenewAccount,omitempty"` // The new account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval.
	AutoRenewPeriod  uint64     `protobuf:"varint,11,opt,name=autoRenewPeriod,proto3" json:"autoRenewPeriod,omitempty"`  // The new interval at which the auto-renew account will be charged to extend the token's expiry.
	Expiry           uint64     `protobuf:"varint,12,opt,name=expiry,proto3" json:"expiry,omitempty"`                    // The new expiry time of the token. Expiry can be updated even if admin key is not set. If the provided expiry is earlier than the current token expiry, transaction wil resolve to INVALID_EXPIRATION_TIME
}

func (x *TokenUpdateTransactionBody) Reset() {
	*x = TokenUpdateTransactionBody{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_TokenUpdate_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenUpdateTransactionBody) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenUpdateTransactionBody) ProtoMessage() {}

func (x *TokenUpdateTransactionBody) ProtoReflect() protoreflect.Message {
	mi := &file_proto_TokenUpdate_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenUpdateTransactionBody.ProtoReflect.Descriptor instead.
func (*TokenUpdateTransactionBody) Descriptor() ([]byte, []int) {
	return file_proto_TokenUpdate_proto_rawDescGZIP(), []int{0}
}

func (x *TokenUpdateTransactionBody) GetToken() *TokenID {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *TokenUpdateTransactionBody) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TokenUpdateTransactionBody) GetTreasury() *AccountID {
	if x != nil {
		return x.Treasury
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetAdminKey() *Key {
	if x != nil {
		return x.AdminKey
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetKycKey() *Key {
	if x != nil {
		return x.KycKey
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetFreezeKey() *Key {
	if x != nil {
		return x.FreezeKey
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetWipeKey() *Key {
	if x != nil {
		return x.WipeKey
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetSupplyKey() *Key {
	if x != nil {
		return x.SupplyKey
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetAutoRenewAccount() *AccountID {
	if x != nil {
		return x.AutoRenewAccount
	}
	return nil
}

func (x *TokenUpdateTransactionBody) GetAutoRenewPeriod() uint64 {
	if x != nil {
		return x.AutoRenewPeriod
	}
	return 0
}

func (x *TokenUpdateTransactionBody) GetExpiry() uint64 {
	if x != nil {
		return x.Expiry
	}
	return 0
}

var File_proto_TokenUpdate_proto protoreflect.FileDescriptor

var file_proto_TokenUpdate_proto_rawDesc = []byte{
	0x0a, 0x17, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x16, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x42, 0x61, 0x73, 0x69, 0x63, 0x54, 0x79, 0x70,
	0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xe2, 0x03, 0x0a, 0x1a, 0x54, 0x6f, 0x6b,
	0x65, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x42, 0x6f, 0x64, 0x79, 0x12, 0x24, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x54,
	0x6f, 0x6b, 0x65, 0x6e, 0x49, 0x44, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x16, 0x0a,
	0x06, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73,
	0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x2c, 0x0a, 0x08, 0x74, 0x72, 0x65,
	0x61, 0x73, 0x75, 0x72, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2e, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44, 0x52, 0x08, 0x74,
	0x72, 0x65, 0x61, 0x73, 0x75, 0x72, 0x79, 0x12, 0x26, 0x0a, 0x08, 0x61, 0x64, 0x6d, 0x69, 0x6e,
	0x4b, 0x65, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x08, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x12,
	0x22, 0x0a, 0x06, 0x6b, 0x79, 0x63, 0x4b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x06, 0x6b, 0x79, 0x63,
	0x4b, 0x65, 0x79, 0x12, 0x28, 0x0a, 0x09, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x65, 0x4b, 0x65, 0x79,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4b,
	0x65, 0x79, 0x52, 0x09, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x65, 0x4b, 0x65, 0x79, 0x12, 0x24, 0x0a,
	0x07, 0x77, 0x69, 0x70, 0x65, 0x4b, 0x65, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x07, 0x77, 0x69, 0x70, 0x65,
	0x4b, 0x65, 0x79, 0x12, 0x28, 0x0a, 0x09, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x4b, 0x65, 0x79,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4b,
	0x65, 0x79, 0x52, 0x09, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x4b, 0x65, 0x79, 0x12, 0x3c, 0x0a,
	0x10, 0x61, 0x75, 0x74, 0x6f, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44, 0x52, 0x10, 0x61, 0x75, 0x74, 0x6f, 0x52,
	0x65, 0x6e, 0x65, 0x77, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x61,
	0x75, 0x74, 0x6f, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x18, 0x0b,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x61, 0x75, 0x74, 0x6f, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x50,
	0x65, 0x72, 0x69, 0x6f, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x18,
	0x0c, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x42, 0x4a, 0x0a,
	0x22, 0x63, 0x6f, 0x6d, 0x2e, 0x68, 0x65, 0x64, 0x65, 0x72, 0x61, 0x68, 0x61, 0x73, 0x68, 0x67,
	0x72, 0x61, 0x70, 0x68, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x6a,
	0x61, 0x76, 0x61, 0x50, 0x01, 0x5a, 0x22, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x68, 0x61, 0x73, 0x68, 0x67, 0x72, 0x61, 0x70, 0x68, 0x2f, 0x68, 0x65, 0x64, 0x65,
	0x72, 0x61, 0x2d, 0x73, 0x64, 0x6b, 0x2d, 0x67, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_proto_TokenUpdate_proto_rawDescOnce sync.Once
	file_proto_TokenUpdate_proto_rawDescData = file_proto_TokenUpdate_proto_rawDesc
)

func file_proto_TokenUpdate_proto_rawDescGZIP() []byte {
	file_proto_TokenUpdate_proto_rawDescOnce.Do(func() {
		file_proto_TokenUpdate_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_TokenUpdate_proto_rawDescData)
	})
	return file_proto_TokenUpdate_proto_rawDescData
}

var file_proto_TokenUpdate_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proto_TokenUpdate_proto_goTypes = []interface{}{
	(*TokenUpdateTransactionBody)(nil), // 0: proto.TokenUpdateTransactionBody
	(*TokenID)(nil),                    // 1: proto.TokenID
	(*AccountID)(nil),                  // 2: proto.AccountID
	(*Key)(nil),                        // 3: proto.Key
}
var file_proto_TokenUpdate_proto_depIdxs = []int32{
	1, // 0: proto.TokenUpdateTransactionBody.token:type_name -> proto.TokenID
	2, // 1: proto.TokenUpdateTransactionBody.treasury:type_name -> proto.AccountID
	3, // 2: proto.TokenUpdateTransactionBody.adminKey:type_name -> proto.Key
	3, // 3: proto.TokenUpdateTransactionBody.kycKey:type_name -> proto.Key
	3, // 4: proto.TokenUpdateTransactionBody.freezeKey:type_name -> proto.Key
	3, // 5: proto.TokenUpdateTransactionBody.wipeKey:type_name -> proto.Key
	3, // 6: proto.TokenUpdateTransactionBody.supplyKey:type_name -> proto.Key
	2, // 7: proto.TokenUpdateTransactionBody.autoRenewAccount:type_name -> proto.AccountID
	8, // [8:8] is the sub-list for method output_type
	8, // [8:8] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_proto_TokenUpdate_proto_init() }
func file_proto_TokenUpdate_proto_init() {
	if File_proto_TokenUpdate_proto != nil {
		return
	}
	file_proto_BasicTypes_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_proto_TokenUpdate_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TokenUpdateTransactionBody); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_TokenUpdate_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_TokenUpdate_proto_goTypes,
		DependencyIndexes: file_proto_TokenUpdate_proto_depIdxs,
		MessageInfos:      file_proto_TokenUpdate_proto_msgTypes,
	}.Build()
	File_proto_TokenUpdate_proto = out.File
	file_proto_TokenUpdate_proto_rawDesc = nil
	file_proto_TokenUpdate_proto_goTypes = nil
	file_proto_TokenUpdate_proto_depIdxs = nil
}
